{"version":3,"sources":["../src/matcher/email-matcher.ts"],"names":[],"mappings":"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","file":"email-matcher.js","sourcesContent":["import { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { Match } from \"../match/match\";\nimport { throwUnhandledCaseError } from '../utils';\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nexport class EmailMatcher extends Matcher {\n\n\t/**\n\t * Valid characters that can be used in the \"local\" part of an email address,\n\t * i.e. the \"name\" part of \"name@site.com\"\n\t */\n\tprotected localPartCharRegex = new RegExp( `[${alphaNumericAndMarksCharsStr}!#$%&'*+/=?^_\\`{|}~-]` );\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tconst tagBuilder = this.tagBuilder,\n\t\t\t  localPartCharRegex = this.localPartCharRegex,\n\t\t\t  matches: Match[] = [],\n\t\t\t  len = text.length,\n\t\t\t  noCurrentEmailAddress = new CurrentEmailAddress();\n\n\t\tlet charIdx = 0,\n\t\t\tstate = State.NonEmailAddress as State,\n\t\t\tcurrentEmailAddress = noCurrentEmailAddress;\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t// const table = new CliTable( {\n\t\t// \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n\t\t// } );\n\n\t\twhile( charIdx < len ) {\n\t\t\tconst char = text.charAt( charIdx );\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tswitch( state ) {\n\t\t\t\tcase State.NonEmailAddress: stateNonEmailAddress( char ); break;\n\t\t\t\tcase State.LocalPart: stateLocalPart( char ); break;\n\t\t\t\tcase State.LocalPartDot: stateLocalPartDot( char ); break;\n\t\t\t\tcase State.AtSign: stateAtSign( char ); break;\n\t\t\t\tcase State.DomainChar: stateDomainChar( char ); break;\n\t\t\t\tcase State.DomainHyphen: stateDomainHyphen( char ); break;\n\t\t\t\tcase State.DomainDot: stateDomainDot( char ); break;\n\t\n\t\t\t\tdefault: \n\t\t\t\t\tthrowUnhandledCaseError( state );\n\t\t\t}\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tcharIdx++;\n\t\t}\n\n\t\t// Capture any valid match at the end of the string\n\t\tcaptureMatchIfValidAndReset();\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t//console.log( '\\n' + table.toString() );\n\t\t\n\t\treturn matches;\n\n\n\t\t// Handles the state when we're not in an email address\n\t\tfunction stateNonEmailAddress( char: string ) {\n\t\t\tif( localPartCharRegex.test( char ) ) {\n\t\t\t\tbeginEmailAddress();\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, continue\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state when we're currently in the \"local part\" of an \n\t\t// email address (as opposed to the \"domain part\")\n\t\tfunction stateLocalPart( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// stay in the \"local part\" of the email address\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailAddressState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state where we've read \n\t\tfunction stateLocalPartDot( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\t// We read a second '.' in a row, not a valid email address \n\t\t\t\t// local part\n\t\t\t\tresetToNonEmailAddressState();\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We read the '@' character immediately after a dot ('.'), not \n\t\t\t\t// an email address\n\t\t\t\tresetToNonEmailAddressState();\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailAddressState();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction stateAtSign( char: string ) {\n\t\t\tif( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailAddressState();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainChar( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.DomainDot;\n\n\t\t\t} else if( char === '-' ) {\n\t\t\t\tstate = State.DomainHyphen;\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\t// Stay in the DomainChar state\n\n\t\t\t} else {\n\t\t\t\t// Anything else, we potentially matched if the criteria has\n\t\t\t\t// been met\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainHyphen( char: string ) {\n\t\t\tif( char === '-' || char === '.' ) {\n\t\t\t\t// Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainDot( char: string ) {\n\t\t\tif( char === '.' || char === '-' ) {\n\t\t\t\t// not valid to have two dots (\"..\") or dot+hypen (\".-\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t\t// After having read a '.' and then a valid domain character,\n\t\t\t\t// we now know that the domain part of the email is valid, and\n\t\t\t\t// we have found at least a partial EmailMatch (however, the\n\t\t\t\t// email address may have additional characters from this point)\n\t\t\t\tcurrentEmailAddress = new CurrentEmailAddress( { \n\t\t\t\t\t...currentEmailAddress, \n\t\t\t\t\thasDomainDot: true \n\t\t\t\t} );\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction beginEmailAddress() {\n\t\t\tstate = State.LocalPart;\n\t\t\tcurrentEmailAddress = new CurrentEmailAddress( { idx: charIdx } );\n\t\t}\n\n\t\tfunction resetToNonEmailAddressState() {\n\t\t\tstate = State.NonEmailAddress;\n\t\t\tcurrentEmailAddress = noCurrentEmailAddress\n\t\t}\n\n\n\t\t/*\n\t\t * Captures the current email address as an EmailMatch if it's valid,\n\t\t * and resets the state to read another email address.\n\t\t */\n\t\tfunction captureMatchIfValidAndReset() {\n\t\t\tif( currentEmailAddress.hasDomainDot ) {  // we need at least one dot in the domain to be considered a valid email address\n\t\t\t\tlet emailAddress = text.slice( currentEmailAddress.idx, charIdx );\n\n\t\t\t\t// If we read a '.' or '-' char that ended the email address\n\t\t\t\t// (valid domain name characters, but only valid email address\n\t\t\t\t// characters if they are followed by something else), strip \n\t\t\t\t// it off now\n\t\t\t\tif( /[-.]$/.test( emailAddress ) ){\n\t\t\t\t\temailAddress = emailAddress.slice( 0, -1 );\n\t\t\t\t}\n\n\t\t\t\tmatches.push( new EmailMatch( {\n\t\t\t\t\ttagBuilder  : tagBuilder,\n\t\t\t\t\tmatchedText : emailAddress,\n\t\t\t\t\toffset      : currentEmailAddress.idx,\n\t\t\t\t\temail       : emailAddress\n\t\t\t\t} ) );\n\t\t\t}\n\n\t\t\tresetToNonEmailAddressState();\n\t\t}\n\t}\n\n}\n\n\nconst enum State {\n\tNonEmailAddress = 0,\n\tLocalPart,\n\tLocalPartDot,\n\tAtSign,\n\tDomainChar,\n\tDomainHyphen,\n\tDomainDot\n}\n\n\nclass CurrentEmailAddress {\n\treadonly idx: number;  // the index of the first character in the email address\n\treadonly hasDomainDot: boolean;\n\n\tconstructor( cfg: Partial<CurrentEmailAddress> = {} ) {\n\t\tthis.idx = cfg.idx !== undefined ? cfg.idx : -1;\n\t\tthis.hasDomainDot = !!cfg.hasDomainDot;\n\t}\n}"]}